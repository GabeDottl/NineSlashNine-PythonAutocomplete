# (generated with --quick)

import collections
from typing import Any, Callable, Iterable, Sized, Tuple, Type, TypeVar, Union

_: int
a: int
b: int
bar: Union[Foo, int]
foo: Foo
x: str
z: int

_Tnamedtuple-T-y = TypeVar('_Tnamedtuple-T-y', bound=`namedtuple-T-y`)

class Foo:
    T: Type[`namedtuple-T-y`]
    t: `namedtuple-T-y`
    x: int
    y: int
    def __init__(self) -> None: ...
    def foofie(self) -> None: ...
    def get_t(self) -> `namedtuple-T-y`: ...
    def inter(self) -> int: ...

class `namedtuple-T-y`(tuple):
    __slots__ = ["y"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str]
    y: Any
    def __getnewargs__(self) -> Tuple[Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[`_Tnamedtuple-T-y`], y) -> `_Tnamedtuple-T-y`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[`_Tnamedtuple-T-y`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-T-y`: ...
    def _replace(self: `_Tnamedtuple-T-y`, **kwds) -> `_Tnamedtuple-T-y`: ...

def namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: bool = ..., rename: bool = ...) -> type: ...
def should_return_1(f) -> Any: ...
